/*
---------------------------------------------------------------------------  
               Copyright � 2005 - 2007 by EntitySpaces, LLC
                           All Rights Reserved. 
---------------------------------------------------------------------------  
                           LICENSE AGREEMENT
---------------------------------------------------------------------------
This License Agreement is between you (�Customer�) and EntitySpaces, LLC, 
the author of the EntitySpaces� software and governs your use of the of the
EntitySpaces class libraries, dynamic link libraries, source code, related 
EntitySpaces templates for MyGeneration Software, and documentation (all of 
which are referred to herein as the "Software").

PLEASE READ THIS SOFTWARE LICENSE AGREEMENT CAREFULLY BEFORE PURCHASING, 
DOWNLOADING OR USING THE SOFTWARE. 

NO REFUNDS ARE POSSIBLE. 

BY PURCHASING, INSTALLING, OR DOWNLOADING THE SOFTWARE YOU ARE CONSENTING 
TO BE BOUND BY THIS AGREEMENT. IF YOU DO NOT AGREE TO ALL OF THE TERMS OF
THIS AGREEMENT DO NOT DOWNLOAD OR PURCHASE THE SOFTWARE.

  * Our developer licenses are licensed per developer seat. A developer seat 
    is required for each developer that uses the EntitySpaces templates to 
    generate code or that uses the generated EntitySpaces API in their 
    programming tasks.

  * EntitySpaces, LLC grants Customer a non-exclusive right to install and 
    use one copy of Software for each License purchased. 

  * Customer may make one (1) archival copy of the Software provided Customer 
    affixes to such copy all copyright, confidentiality, and proprietary 
    notices that appear on the original. 

The binary redistributables are royalty free to the original Licensee and 
can be distributed with applications.
    
Binary redistributables include:
 
 1) EntitySpace.Core.dll
 2) EntitySpace.Core.Ce.dll 
 3) EntitySpaces.Interfaces.dll
 4) EntitySpaces.Interfaces.Ce.dll
 5) EntitySpaces.SqlClientProvider.dll
 6) EntitySpaces.SqlClientProvider.Ce.dll
 7) EntitySpaces.MSAccessProvider.dll 
 8) EntitySpaces.OracleClientProvider.dll
 9) EntitySpaces.MySqlClientProvider.dll
10) EntitySpaces.VistaDBProvider.dll  
11) EntitySpaces.VistaDBProvider.Ce.dll  
12) EntitySpaces.NpgsqlProvider.dll  
13) EntitySpaces.Web.dll  
14) EntitySpaces.Web.Design.dll  
15) EntitySpaces.Loader.dll  
16) EntitySpaces.Loader.Ce.dll  
17) EntitySpaces.LoaderMT.dll  
18) EntitySpaces.LoaderMT.Ce.dll 
  
EntitySpaces binary redistributables cannot be used by third parties to build
applications or components.

Source code generated by the EntitySpaces templates for MyGeneration is a 
derivative work. When used under a valid License, EntitySpaces, LLC grants
Customer the right to use, modify, and redistribute any source code generated
by the EntitySpaces templates for MyGeneration.

Customer that has purchased Source Code License may alter the EntitySpaces 
Core, Interfaces, or Provider(s) source code and distribute the modified 
binary redistributables with applications. Customer created binary 
redistributables from the EntitySpaces source code cannot be used by anyone,
including the original license holder, to create a product that competes with
the EntitySpaces .NET Architecture. Customer created binary redistributables
from the EntitySpaces source code cannot be used by third parties to build
applications or components. Neither the original nor altered source code may
be distributed.

EXCEPT AS EXPRESSLY AUTHORIZED ABOVE, CUSTOMER SHALL NOT: COPY, IN WHOLE OR
IN PART, SOFTWARE OR DOCUMENTATION; MODIFY THE SOFTWARE; REVERSE COMPILE OR
REVERSE ASSEMBLE ALL OR ANY PORTION OF THE SOFTWARE; OR RENT, LEASE, 
DISTRIBUTE, SELL, MAKE AVAILABLE FOR DOWNLOAD, OR CREATE DERIVATIVE WORKS
OF THE SOFTWARE OR SOURCE CODE. 

Customer agrees that aspects of the licensed materials, including the specific
design and structure of individual programs, constitute trade secrets and/or
copyrighted material of EntitySpaces, LLC. Customer agrees not to disclose, 
provide, or otherwise make available such trade secrets or copyrighted 
material in any form to any third party without the prior written consent
of EntitySpaces, LLC. Customer agrees to implement reasonable security
measures to protect such trade secrets and copyrighted material. Title
to Software and documentation shall remain solely with EntitySpaces, LLC.

No Warranty 
===============
THE SOFTWARE IS BEING DELIVERED TO YOU "AS IS" AND EntitySpaces, LLC MAKES
NO WARRANTY AS TO ITS USE, RELIABILITY OR PERFORMANCE. EntitySpaces, LLC DOES
NOT AND CANNOT WARRANT THE PERFORMANCE OR RESULTS YOU MAY OBTAIN BY USING THE
SOFTWARE. EntitySpaces, LLC MAKES NO WARRANTIES, EXPRESS OR IMPLIED, AS TO
NONINFRINGEMENT OF THIRD PARTY RIGHTS, TITLE, MERCHANTABILITY, OR FITNESS
FOR ANY PARTICULAR PURPOSE. YOU ASSUME ALL RISK ASSOCIATED WITH THE QUALITY,
PERFORMANCE, INSTALLATION AND USE OF THE SOFTWARE INCLUDING, BUT NOT LIMITED
TO, THE RISKS OF PROGRAM ERRORS, DAMAGE TO EQUIPMENT, LOSS OF DATA OR SOFTWARE
PROGRAMS, OR UNAVAILABILITY OR INTERRUPTION OF OPERATIONS. YOU ARE SOLELY
RESPONSIBLE FOR DETERMINING THE APPROPRIATENESS OF USE OF THE SOFTWARE AND
ASSUME ALL RISKS ASSOCIATED WITH ITS USE.

Indemnification
===============
You agree to indemnify and hold EntitySpaces, LLC, parents, subsidiaries,
affiliates, officers and employees, harmless from any claim or demand,
including reasonable attorneys' fees, made by any third party due to or 
arising out of your use of the Software, or the infringement by you, of
any intellectual property or other right of any person or entity.

Limitation of Liability
===============
IN NO EVENT WILL EntitySpaces, LLC BE LIABLE TO YOU FOR ANY INDIRECT,
INCIDENTAL, SPECIAL, PUNITIVE, CONSEQUENTIAL, OR OTHER DAMAGES WHATSOEVER,
OR ANY LOSS OF REVENUE, DATA, USE, OR PROFITS, EVEN IF EntitySpaces, LLC
HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES, AND REGARDLESS OF
WHETHER THE CLAIM IS BASED UPON ANY CONTRACT, TORT OR OTHER LEGAL OR
EQUITABLE THEORY.

This License is effective until terminated. Customer may terminate this
License at any time by destroying all copies of Software including any
documentation. This License will terminate immediately without notice
from EntitySpaces, LLC if Customer fails to comply with any provision
of this License. Upon termination, Customer must destroy all copies of
Software.

Software, including technical data, is subject to U.S. export control
laws, including the U.S. Export Administration Act and its associated
regulations, and may be subject to export or import regulations in other
countries. Customer agrees to comply strictly with all such regulations
and acknowledges that it has the responsibility to obtain licenses to
export, re-export, or import Software.

This License shall be governed by and construed in accordance with the
laws of the State of Indiana, United States of America, as if performed
wholly within the state and without giving effect to the principles 
of conflict of law. If any portion hereof is found to be void or 
unenforceable, the remaining provisions of this License shall remain
in full force and effect. This License constitutes the entire License
between the parties with respect to the use of the Software.
  
*/

using System;
using System.Collections;
using System.IO;
using System.Xml;
// ReSharper disable MemberCanBePrivate.Global

namespace EntitySpaces.MetadataEngine
{
  /// <summary>
  /// The esPlugIn for MyGeneration is used to encapsulate the logic used to determine class names and property names for EntitySpaces. 
  /// The esPlugIn allows users to customize the naming conventions of their EntitySpaces classes.
  /// </summary>
  /// <remarks>
  /// The Pascal convention can be turned off via the <see cref="UseRawNames"/> property however it is not recommended.
  /// The default naming conventions are stored in a file called esPluginSettings.xml
  /// located in the MyGeneration Settings folder.
  /// The default naming conventions for EntitySpaces are listed below.
  /// <BR></BR>
  /// Using a table named "my_employees" the default "Concrete" classes are as follows:
  /// <list type="table">
  ///		<item><term>esPlugIn.Entity("my_employees")</term><description>MyEmployees</description></item>
  ///		<item><term>esPlugIn.Collection("my_employees")</term><description>MyEmployeesCollection</description></item>
  ///		<item><term>esPlugIn.Query("my_employees")</term><description>MyEmployeesQuery</description></item>	
  ///		<item><term>esPlugIn.Metadata("my_employees")</term><description>MyEmployeesMetadata</description></item>	
  ///	</list>
  ///	<BR></BR>
  /// Using a table named "my_employees" the default "Abstract/MustInherit" classes are as follows:
  /// <BR></BR>
  /// <list type="table">
  ///		<item><term>esPlugIn.esEntity("my_employees")</term><description>esMyEmployees</description></item>
  ///		<item><term>esPlugIn.esCollection("my_employees")</term><description>esMyEmployeesCollection</description></item>
  ///		<item><term>esPlugIn.esQuery("my_employees")</term><description>esMyEmployeesQuery</description></item>	
  ///	</list>
  ///	<BR></BR>
  /// The default formula for constructing Stored Procedure names is:
  /// <code>
  /// Formula = [<see cref="sProcPrefix"/> + source.Name + Verb + <see cref="sProcSuffix"/>]
  /// </code>
  /// Where Verb is one of the following:
  /// <see cref="sProcInsert"/>,
  /// <see cref="sProcUpdate"/>,
  /// <see cref="sProcDelete"/>,
  /// <see cref="sProcLoadAll"/>,
  /// <see cref="sProcLoadByPK"/>
  /// <BR></BR>
  /// Using a table named "my_employees" the default Stored Procedure names are as follows:
  /// <BR></BR>
  /// <list type="table">
  ///		<item><term>esPlugin.ProcInsert("my_employees")</term><description>proc_my_employeesInsert</description></item>
  ///		<item><term>esPlugin.ProcUpdate("my_employees")</term><description>proc_my_employeesUpdate</description></item>
  ///		<item><term>esPlugin.ProcDelete("my_employees")</term><description>proc_my_employeesDelete</description></item>
  ///		<item><term>esPlugin.ProcLoadAll("my_employees")</term><description>proc_my_employeesLoadAll</description></item>
  ///		<item><term>esPlugin.ProcLoadByPK("my_employees")</term><description>proc_my_employeesLoadByPrimaryKey</description></item>
  ///	</list>
  /// You can use <see cref="ProcVerbFirst"/> to change from the default EntityVerb
  /// order to VerbEntity order, but it is not recommended.
  /// <BR></BR>
  /// </remarks>
  public class esPlugIn
  {
    private esSettings Settings;

    /// <summary>
    /// Reads the default esPlugin naming conventions from esPluginSettings.xml
    /// (located in the MyGeneration Settings folder.)
    /// </summary>
    /// <remarks>
    /// The default settings can be overridden at runtime by setting the
    /// appropriate Property in template code.
    /// </remarks>
    public esPlugIn(esSettings settings)
    {
      Settings = settings;
    }

    #region Naming Methods

    /// <summary>
    /// The prefix used when building abstract class names as esEntity, esCollection and others.
    /// </summary>
    /// <remarks>
    /// The default is "es", as in "esEntity", "esCollection" and others. You can modify this property to override the default of "es".
    /// See <see cref="esEntity"/>, <see cref="esCollection"/>, <see cref="esQuery"/>
    /// </remarks>
    public string sPrefix => Settings.AbstractPrefix;

    /// <summary>
    /// The suffix used when building abstract and concrete "Entity" class names. 
    /// </summary>
    /// <remarks>
    /// The default is "" or blank meaning a Table with the name "Employees" 
    /// would be called "Employees". See <see cref="Entity"/> and <see cref="esEntity"/>
    /// </remarks>
    public string sEntity => Settings.EntitySuffix;

    /// <summary>
    /// The suffix used when building abstract and concrete "Collection" class names. 
    /// </summary>
    /// <remarks>
    /// The default is "Collection" meaning a Table with the name "Employees" 
    /// would be called "EmployeesCollection". See <see cref="Collection"/> and <see cref="esCollection"/>
    /// </remarks>
    public string sCollection => Settings.CollectionSuffix;

    /// <summary>
    /// The suffix used when building abstract and concrete "Query" class names. 
    /// </summary>
    /// <remarks>
    /// The default is "Query" meaning a Table with the name "Employees" 
    /// would be called "EmployeesQuery". See <see cref="Query"/> and <see cref="esQuery"/>
    /// </remarks>
    public string sQuery => Settings.QuerySuffix;

    /// <summary>
    /// The suffix used when building abstract and concrete "ProxyStub" class names. 
    /// </summary>
    /// <remarks>
    /// The default is "ProxyStub" or blank meaning a Table with the name "Employees" 
    /// would be called "EmployeesProxyStub". See <see cref="ProxyStub"/>
    /// </remarks>
    public string sProxyStub => Settings.ProxyStubSuffix;

    /// <summary>
    /// The suffix used when building concrete "Metadata" class names. 
    /// </summary>
    /// <remarks>
    /// The default is "Metadata" meaning a Table with the name "Employees" 
    /// would be called "EmployeesMetadata". There are no abstract classes for the Metadata type.
    /// See <see cref="sMetadata"/>
    /// </remarks>
    public string sMetadata => Settings.MetadataSuffix;

    /// <summary>
    /// The prefix used when building stored procedure names. 
    /// </summary>
    /// <remarks>
    /// The default is "proc_" meaning stored procedures will begin with "proc_" 
    /// </remarks>
    public string sProcPrefix => Settings.ProcPrefix;

    /// <summary>
    /// The suffix used when building stored procedure names. 
    /// </summary>
    /// <remarks>
    /// The default is "" meaning no suffix is defined.
    /// </remarks>
    public string sProcSuffix => Settings.ProcSuffix;

    /// <summary>
    /// Used when building the Insert stored procedure name. 
    /// </summary>
    /// <remarks>
    /// The default is "Insert".
    /// </remarks>
    public string sProcInsert => Settings.ProcInsert;

    /// <summary>
    /// Used when building the Update stored procedure name. 
    /// </summary>
    /// <remarks>
    /// The default is "Update".
    /// </remarks>
    public string sProcUpdate => Settings.ProcUpdate;

    /// <summary>
    /// Used when building the Delete stored procedure name. 
    /// </summary>
    /// <remarks>
    /// The default is "Delete".
    /// </remarks>
    public string sProcDelete => Settings.ProcDelete;

    /// <summary>
    /// Used when building the LoadAll stored procedure name. 
    /// </summary>
    /// <remarks>
    /// The default is "LoadAll".
    /// </remarks>
    public string sProcLoadAll => Settings.ProcLoadAll;

    /// <summary>
    /// Used when building the LoadByPk stored procedure name. 
    /// </summary>
    /// <remarks>
    /// The default is "LoadByPrimaryKey".
    /// </remarks>
    public string sProcLoadByPK => Settings.ProcLoadByPK;

    #endregion

    #region Concrete Classes

    #region Entity

    /// <summary>
    /// Used to create the Entity class name.
    /// </summary>
    /// <remarks>Formula = [source.Name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// &lt;%=esPlugIn.Entity(source)%&gt; obj = new &lt;%=esPlugIn.Entity(source)%&gt;(); 
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// &lt;%=esPlugIn.Entity(source)%&gt; obj = new &lt;%=esPlugIn.Entity(source)%&gt;(); 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The Entity class name</returns>
    public string Entity(esPluginSource source)
    {
      if (source.table != null)
        return Entity(source.table);
      else
        return Entity(source.view);
    }

    /// <summary>
    /// Used to create the Entity class name.
    /// </summary>
    /// <remarks>Formula = [table.Name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.Entity(table)%&gt; obj = new &lt;%=esPlugIn.Entity(table)%&gt;(); 
    /// 
    /// // Produces
    /// Employees obj = new Employees();
    /// </code>
    /// </example>
    /// <param name="table">The ITable to build an Entity class name for</param>
    /// <returns>The Entity class name</returns>
    public string Entity(ITable table)
    {
      if (table.Alias != table.Name)
        return Utils.RemoveIllegalCharacters(table.Alias) + sEntity;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return table.Schema + "_" + Entity(table.Name);
        }
        else
        {
          return Entity(table.Name);
        }
      }
    }

    /// <summary>
    /// Used to create the Entity class name.
    /// </summary>
    /// <remarks>Formula = [view.Name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// &lt;%=esPlugIn.Entity(view)%&gt; obj = new &lt;%=esPlugIn.Entity(view)%&gt;(); 
    /// 
    /// // Produces
    /// ProductSalesfor1997 obj = new ProductSalesfor1997();
    /// </code>
    /// </example>
    /// <param name="view">The IView to build an Entity class name for</param>
    /// <returns>The Entity class name</returns>
    public string Entity(IView view)
    {
      if (view.Alias != view.Name)
        return Utils.RemoveIllegalCharacters(view.Alias) + sEntity;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return view.Schema + "_" + Entity(view.Name);
        }
        else
        {
          return Entity(view.Name);
        }
      }
    }

    /// <summary>
    /// This method can take in a raw table name or view name.
    /// </summary>
    /// <remarks>Formula = [name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// &lt;%=esPlugIn.Entity("my_object")%&gt; obj = new &lt;%=esPlugIn.Entity("my_object")%&gt;(); 
    /// 
    /// // Produces
    /// MyObject obj = new MyObject();
    /// </code>
    /// </example>
    /// <param name="name">Raw string used to build an Entity class name</param>
    /// <returns>The Entity class name</returns>
    public string Entity(string name)
    {
      return EntityCore(name) + sEntity;
    }
    #endregion

    #region Collection

    /// <summary>
    /// Used to create the Collection concrete class name.
    /// </summary>
    /// <remarks>Formula = [source.Name + <see cref="sCollection"/>]
    /// <seealso cref="sCollection"/><seealso cref="esCollection"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// &lt;%=esPlugIn.Collection(source)%&gt; obj = new &lt;%=esPlugIn.Collection(source)%&gt;(); 
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// &lt;%=esPlugIn.Collection(source)%&gt; obj = new &lt;%=esPlugIn.Collection(source)%&gt;(); 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on a ITable/IView transparently</param>
    /// <returns>The Collection class name</returns>
    public string Collection(esPluginSource source)
    {
      if (source.table != null)
        return Collection(source.table);
      else
        return Collection(source.view);
    }

    /// <summary>
    /// Used to create the Collection concrete class name.
    /// </summary>
    /// <remarks>Formula = [table.Name + <see cref="sCollection"/>]
    /// <seealso cref="sCollection"/><seealso cref="esCollection"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.Collection(table)%&gt; obj = new &lt;%=esPlugIn.Collection(table)%&gt;(); 
    /// 
    /// // Produces
    /// EmployeesCollection obj = new EmployeesCollection();
    /// </code>
    /// </example>
    /// <param name="table">The ITable to build a Collection class name for</param>
    /// <returns>The Collection class name</returns>
    public string Collection(ITable table)
    {
      if (table.Alias != table.Name)
        return Utils.RemoveIllegalCharacters(table.Alias) + sCollection;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return table.Schema + "_" + Collection(table.Name);
        }
        else
        {
          return Collection(table.Name);
        }
      }
    }

    /// <summary>
    /// Used to create the Collection concrete class name.
    /// </summary>
    /// <remarks>Formula = [view.Name + <see cref="sCollection"/>]
    /// <seealso cref="sCollection"/><seealso cref="esCollection"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// &lt;%=esPlugIn.Collection(view)%&gt; obj = new &lt;%=esPlugIn.Collection(view)%&gt;(); 
    /// 
    /// // Produces
    /// ProductSalesfor1997Collection obj = new ProductSalesfor1997Collection();
    /// </code>
    /// </example>
    /// <param name="view">The IView to build a Collection class name for</param>
    /// <returns>The Collection class name</returns>
    public string Collection(IView view)
    {
      if (view.Alias != view.Name)
        return Utils.RemoveIllegalCharacters(view.Alias) + sCollection;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return view.Schema + "_" + Collection(view.Name);
        }
        else
        {
          return Collection(view.Name);
        }
      }
    }

    /// <summary>
    /// This method can take in a raw table name or view name.
    /// </summary>
    /// <remarks>Formula = [name + <see cref="sCollection"/>]
    /// <seealso cref="sCollection"/><seealso cref="esCollection"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// &lt;%=esPlugIn.Collection("my_object")%&gt; obj = new &lt;%=esPlugIn.Collection("my_object")%&gt;(); 
    /// 
    /// // Produces
    /// MyObjectCollection obj = new MyObjectCollection();
    /// </code>
    /// </example>
    /// <param name="name">Raw string used to build a Collection class name</param>
    /// <returns>The Collection class name</returns>
    public string Collection(string name)
    {
      return EntityCore(name) + sCollection;
    }
    #endregion

    #region Query

    /// <summary>
    /// Used to create the Query  concrete class name.
    /// </summary>
    /// <remarks>Formula = [source.Name + <see cref="sQuery"/>]
    /// <seealso cref="sQuery"/><seealso cref="esQuery"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// &lt;%=esPlugIn.Query(source)%&gt; obj = new &lt;%=esPlugIn.Query(source)%&gt;(); 
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// &lt;%=esPlugIn.Query(source)%&gt; obj = new &lt;%=esPlugIn.Query(source)%&gt;(); 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on a ITable/IView transparently</param>
    /// <returns>The Query class name</returns>
    public string Query(esPluginSource source)
    {
      if (source.table != null)
        return Query(source.table);
      else
        return Query(source.view);
    }

    /// <summary>
    /// Used to create the Query  concrete class name.
    /// </summary>
    /// <remarks>Formula = [table.Name + <see cref="sQuery"/>]
    /// <seealso cref="sQuery"/><seealso cref="esQuery"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.Query(table)%&gt; obj = new &lt;%=esPlugIn.Query(table)%&gt;(); 
    /// 
    /// // Produces
    /// EmployeesQuery obj = new EmployeesQuery();
    /// </code>
    /// </example> 
    /// <param name="table">The ITable to build a Query class name for</param>
    /// <returns>The Query class name</returns>
    public string Query(ITable table)
    {
      if (table.Alias != table.Name)
        return Utils.RemoveIllegalCharacters(table.Alias) + sQuery;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return table.Schema + "_" + Query(table.Name);
        }
        else
        {
          return Query(table.Name);
        }
      }
    }

    /// <summary>
    /// Used to create the Query concrete class name.
    /// </summary>
    /// <remarks>Formula = [view.Name + <see cref="sQuery"/>]
    /// <seealso cref="sQuery"/><seealso cref="esQuery"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// &lt;%=esPlugIn.Query(view)%&gt; obj = new &lt;%=esPlugIn.Query(view)%&gt;(); 
    /// 
    /// // Produces
    /// ProductSalesfor1997Query obj = new ProductSalesfor1997Query();
    /// </code>
    /// </example>
    /// <param name="view">The IView to build a Query class name for</param>
    /// <returns>The Query class name</returns>
    public string Query(IView view)
    {
      if (view.Alias != view.Name)
        return Utils.RemoveIllegalCharacters(view.Alias) + sQuery;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return view.Schema + "_" + Query(view.Name);
        }
        else
        {
          return Query(view.Name);
        }
      }
    }

    /// <summary>
    /// This method can take in a raw table name or view name.
    /// </summary>
    /// <remarks>Formula = [name + <see cref="sQuery"/>]
    /// <seealso cref="sQuery"/><seealso cref="esQuery"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// &lt;%=esPlugIn.Query("my_object")%&gt; obj = new &lt;%=esPlugIn.Query("my_object")%&gt;(); 
    /// 
    /// // Produces
    /// MyObjectQuery obj = new MyObjectQuery();
    /// </code>
    /// </example> 
    /// <param name="name">Raw string used to build a Query class name</param>
    /// <returns>The Query class name</returns>
    public string Query(string name)
    {
      return EntityCore(name) + sQuery;
    }
    #endregion

    #region ProxyStub
    /// <summary>
    /// Used to create the Entity class name.
    /// </summary>
    /// <remarks>Formula = [source.Name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// &lt;%=esPlugIn.Entity(source)%&gt; obj = new &lt;%=esPlugIn.Entity(source)%&gt;(); 
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// &lt;%=esPlugIn.Entity(source)%&gt; obj = new &lt;%=esPlugIn.Entity(source)%&gt;(); 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The Entity class name</returns>
    public string ProxyStub(esPluginSource source)
    {
      if (source.table != null)
        return ProxyStub(source.table);
      else
        return ProxyStub(source.view);
    }

    /// <summary>
    /// Used to create the Entity class name.
    /// </summary>
    /// <remarks>Formula = [table.Name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.Entity(table)%&gt; obj = new &lt;%=esPlugIn.Entity(table)%&gt;(); 
    /// 
    /// // Produces
    /// Employees obj = new Employees();
    /// </code>
    /// </example>
    /// <param name="table">The ITable to build an Entity class name for</param>
    /// <returns>The Entity class name</returns>
    public string ProxyStub(ITable table)
    {
      if (table.Alias != table.Name)
        return Utils.RemoveIllegalCharacters(table.Alias) + sProxyStub;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return table.Schema + "_" + ProxyStub(table.Name);
        }
        else
        {
          return ProxyStub(table.Name);
        }
      }
    }

    /// <summary>
    /// Used to create the Entity class name.
    /// </summary>
    /// <remarks>Formula = [view.Name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// &lt;%=esPlugIn.Entity(view)%&gt; obj = new &lt;%=esPlugIn.Entity(view)%&gt;(); 
    /// 
    /// // Produces
    /// ProductSalesfor1997 obj = new ProductSalesfor1997();
    /// </code>
    /// </example>
    /// <param name="view">The IView to build an Entity class name for</param>
    /// <returns>The Entity class name</returns>
    public string ProxyStub(IView view)
    {
      if (view.Alias != view.Name)
        return Utils.RemoveIllegalCharacters(view.Alias) + sProxyStub;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return view.Schema + "_" + ProxyStub(view.Name);
        }
        else
        {
          return ProxyStub(view.Name);
        }
      }
    }

    /// <summary>
    /// This method can take in a raw table name or view name.
    /// </summary>
    /// <remarks>Formula = [name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// &lt;%=esPlugIn.Entity("my_object")%&gt; obj = new &lt;%=esPlugIn.Entity("my_object")%&gt;(); 
    /// 
    /// // Produces
    /// MyObject obj = new MyObject();
    /// </code>
    /// </example>
    /// <param name="name">Raw string used to build an Entity class name</param>
    /// <returns>The Entity class name</returns>
    public string ProxyStub(string name)
    {
      return EntityCore(name) + sProxyStub;
    }

    #endregion

    #region ProxyStubCollection
    /// <summary>
    /// Used to create the Entity class name.
    /// </summary>
    /// <remarks>Formula = [source.Name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// &lt;%=esPlugIn.Entity(source)%&gt; obj = new &lt;%=esPlugIn.Entity(source)%&gt;(); 
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// &lt;%=esPlugIn.Entity(source)%&gt; obj = new &lt;%=esPlugIn.Entity(source)%&gt;(); 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The Entity class name</returns>
    public string ProxyStubCollection(esPluginSource source)
    {
      if (source.table != null)
        return ProxyStubCollection(source.table);
      else
        return ProxyStubCollection(source.view);
    }

    /// <summary>
    /// Used to create the Entity class name.
    /// </summary>
    /// <remarks>Formula = [table.Name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.Entity(table)%&gt; obj = new &lt;%=esPlugIn.Entity(table)%&gt;(); 
    /// 
    /// // Produces
    /// Employees obj = new Employees();
    /// </code>
    /// </example>
    /// <param name="table">The ITable to build an Entity class name for</param>
    /// <returns>The Entity class name</returns>
    public string ProxyStubCollection(ITable table)
    {
      if (table.Alias != table.Name)
        return Utils.RemoveIllegalCharacters(table.Alias) + sCollection + sProxyStub;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return table.Schema + "_" + ProxyStubCollection(table.Name);
        }
        else
        {
          return ProxyStubCollection(table.Name);
        }
      }
    }

    /// <summary>
    /// Used to create the Entity class name.
    /// </summary>
    /// <remarks>Formula = [view.Name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// &lt;%=esPlugIn.Entity(view)%&gt; obj = new &lt;%=esPlugIn.Entity(view)%&gt;(); 
    /// 
    /// // Produces
    /// ProductSalesfor1997 obj = new ProductSalesfor1997();
    /// </code>
    /// </example>
    /// <param name="view">The IView to build an Entity class name for</param>
    /// <returns>The Entity class name</returns>
    public string ProxyStubCollection(IView view)
    {
      if (view.Alias != view.Name)
        return Utils.RemoveIllegalCharacters(view.Alias) + sCollection + sProxyStub;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return view.Schema + "_" + ProxyStubCollection(view.Name);
        }
        else
        {
          return ProxyStubCollection(view.Name);
        }
      }
    }

    /// <summary>
    /// This method can take in a raw table name or view name.
    /// </summary>
    /// <remarks>Formula = [name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// &lt;%=esPlugIn.Entity("my_object")%&gt; obj = new &lt;%=esPlugIn.Entity("my_object")%&gt;(); 
    /// 
    /// // Produces
    /// MyObject obj = new MyObject();
    /// </code>
    /// </example>
    /// <param name="name">Raw string used to build an Entity class name</param>
    /// <returns>The Entity class name</returns>
    public string ProxyStubCollection(string name)
    {
      return EntityCore(name) + sCollection + sProxyStub;
    }

    #endregion

    #region ProxyStubQuery
    /// <summary>
    /// Used to create the Entity class name.
    /// </summary>
    /// <remarks>Formula = [source.Name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// &lt;%=esPlugIn.Entity(source)%&gt; obj = new &lt;%=esPlugIn.Entity(source)%&gt;(); 
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// &lt;%=esPlugIn.Entity(source)%&gt; obj = new &lt;%=esPlugIn.Entity(source)%&gt;(); 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The Entity class name</returns>
    public string ProxyStubQuery(esPluginSource source)
    {
      if (source.table != null)
        return ProxyStubQuery(source.table);
      else
        return ProxyStubQuery(source.view);
    }

    /// <summary>
    /// Used to create the Entity class name.
    /// </summary>
    /// <remarks>Formula = [table.Name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.Entity(table)%&gt; obj = new &lt;%=esPlugIn.Entity(table)%&gt;(); 
    /// 
    /// // Produces
    /// Employees obj = new Employees();
    /// </code>
    /// </example>
    /// <param name="table">The ITable to build an Entity class name for</param>
    /// <returns>The Entity class name</returns>
    public string ProxyStubQuery(ITable table)
    {
      if (table.Alias != table.Name)
        return Utils.RemoveIllegalCharacters(table.Alias) + sQuery + sProxyStub;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return table.Schema + "_" + ProxyStubQuery(table.Name);
        }
        else
        {
          return ProxyStubQuery(table.Name);
        }
      }
    }

    /// <summary>
    /// Used to create the Entity class name.
    /// </summary>
    /// <remarks>Formula = [view.Name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// &lt;%=esPlugIn.Entity(view)%&gt; obj = new &lt;%=esPlugIn.Entity(view)%&gt;(); 
    /// 
    /// // Produces
    /// ProductSalesfor1997 obj = new ProductSalesfor1997();
    /// </code>
    /// </example>
    /// <param name="view">The IView to build an Entity class name for</param>
    /// <returns>The Entity class name</returns>
    public string ProxyStubQuery(IView view)
    {
      if (view.Alias != view.Name)
        return Utils.RemoveIllegalCharacters(view.Alias) + sQuery + sProxyStub;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return view.Schema + "_" + ProxyStubQuery(view.Name);
        }
        else
        {
          return ProxyStubQuery(view.Name);
        }
      }
    }

    /// <summary>
    /// This method can take in a raw table name or view name.
    /// </summary>
    /// <remarks>Formula = [name + <see cref="sEntity"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// &lt;%=esPlugIn.Entity("my_object")%&gt; obj = new &lt;%=esPlugIn.Entity("my_object")%&gt;(); 
    /// 
    /// // Produces
    /// MyObject obj = new MyObject();
    /// </code>
    /// </example>
    /// <param name="name">Raw string used to build an Entity class name</param>
    /// <returns>The Entity class name</returns>
    public string ProxyStubQuery(string name)
    {
      return EntityCore(name) + sQuery + sProxyStub;
    }

    #endregion

    #region Metadata

    /// <summary>
    /// Used to create the Metadata or concrete class name.
    /// </summary>
    /// <remarks>Formula = [source.Name + <see cref="sMetadata"/>]. There is no abstract class for the Metadata type.
    /// <seealso cref="sMetadata"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// public class &lt;%=esPlugIn.Metadata(table)%&gt; 
    /// {
    /// }
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// public class &lt;%=esPlugIn.Metadata(view)%&gt;
    /// {
    /// } 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The Metadata class name</returns>
    public string Metadata(esPluginSource source)
    {
      if (source.table != null)
        return Metadata(source.table);
      else
        return Metadata(source.view);
    }

    /// <summary>
    /// Used to create the Metadata or concrete class name.
    /// </summary>
    /// <remarks>Formula = [table.Name + <see cref="sMetadata"/>]. There is no abstract class for the Metadata type.
    /// <seealso cref="sMetadata"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// public class &lt;%=esPlugIn.Metadata(table)%&gt;
    /// {
    /// }
    /// 
    /// // Produces
    /// public class EmployeesMetadata
    /// {
    /// }
    /// </code>
    /// </example> 
    /// <param name="table">The ITable to build a Metadata class name for</param>
    /// <returns>The Metadata class name</returns>
    public string Metadata(ITable table)
    {
      if (table.Alias != table.Name)
        return Utils.RemoveIllegalCharacters(table.Alias) + sMetadata;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return table.Schema + "_" + Metadata(table.Name);
        }
        else
        {
          return Metadata(table.Name);
        }
      }
    }

    /// <summary>
    /// Used to create the Metadata or concrete class name.
    /// </summary>
    /// <remarks>Formula = [view.Name + <see cref="sMetadata"/>]. There is no abstract class for the Metadata type.
    /// <seealso cref="sMetadata"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// public class &lt;%=esPlugIn.Metadata(view)%&gt;\
    /// {
    /// }
    /// 
    /// // Produces
    /// public class ProductSalesfor1997Metadata
    /// {
    /// }
    /// </code>
    /// </example> 
    /// <param name="view">The IView to build a Metadata class name for</param>
    /// <returns>The Metadata class name</returns>
    public string Metadata(IView view)
    {
      if (view.Alias != view.Name)
        return Utils.RemoveIllegalCharacters(view.Alias) + sMetadata;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return view.Schema + "_" + Metadata(view.Name);
        }
        else
        {
          return Metadata(view.Name);
        }
      }
    }

    /// <summary>
    /// This method can take in a raw table name or view name.
    /// </summary>
    /// <remarks>Formula = [name + <see cref="sMetadata"/>]. There is no abstract class for the Metadata type.
    /// <seealso cref="sMetadata"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// public class &lt;%=esPlugIn.Metadata("my_object")%&gt;
    /// {
    /// } 
    /// 
    /// // The result of the code above.
    /// public class MyObjectMetadata
    /// {
    /// }
    /// </code>
    /// </example>
    /// <param name="name">Raw string used to build a Metadata class name</param>
    /// <returns>The Metadata class name</returns>
    public string Metadata(string name)
    {
      return EntityCore(name) + sMetadata;
    }
    #endregion

    #endregion

    #region Abstract Classes

    #region esEntity

    /// <summary>
    /// Used to create the esEntity or abstract class name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sPrefix"/> + source.Name + <see cref="sEntity"/>]
    /// <seealso cref="sPrefix"/><seealso cref="sEntity"/><seealso cref="Entity"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// public class &lt;%=esPlugIn.Entity(source)%&gt; : &lt;%=esPlugIn.esEntity(source)%&gt; 
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// public class &lt;%=esPlugIn.Entity(source)%&gt; : &lt;%=esPlugIn.esEntity(source)%&gt; 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The esEntity or abstract class name</returns>
    public string esEntity(esPluginSource source)
    {
      if (source.table != null)
        return esEntity(source.table);
      else
        return esEntity(source.view);
    }

    /// <summary>
    /// Used to create the esEntity or abstract class name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sPrefix"/> + table.Name + <see cref="sEntity"/>]
    /// <seealso cref="sPrefix"/><seealso cref="sEntity"/><seealso cref="Entity"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// public class &lt;%=esPlugIn.Entity(table)%&gt; : &lt;%=esPlugIn.esEntity(table)%&gt;
    /// {
    /// }
    /// 
    /// // Produces
    /// public class Employees : esEmployees
    /// {
    /// }
    /// </code>
    /// </example> 
    /// <param name="table">The ITable to build an esEntity or abstract class name for</param>
    /// <returns>The esEntity or abstract class name</returns>
    public string esEntity(ITable table)
    {
      if (table.Alias != table.Name)
        return sPrefix + Utils.RemoveIllegalCharacters(table.Alias) + sEntity;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return table.Schema + "_" + esEntity(table.Name);
        }
        else
        {
          return esEntity(table.Name);
        }
      }
    }

    /// <summary>
    /// Used to create the esEntity or abstract class name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sPrefix"/> + view.Name + <see cref="sEntity"/>]
    /// <seealso cref="sPrefix"/><seealso cref="sEntity"/><seealso cref="Entity"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// public class &lt;%=esPlugIn.Entity(view)%&gt; : &lt;%=esPlugIn.esEntity(view)%&gt;
    /// {
    /// } 
    /// 
    /// // Produces
    /// public class ProductSalesfor1997 : esProductSalesfor1997
    /// {
    /// }
    /// </code>
    /// </example>
    /// <param name="view">The IView to build an esEntity or abstract class name for</param>
    /// <returns>The esEntity or abstract class name</returns>
    public string esEntity(IView view)
    {
      if (view.Alias != view.Name)
        return sPrefix + Utils.RemoveIllegalCharacters(view.Alias) + sEntity;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return view.Schema + "_" + esEntity(view.Name);
        }
        else
        {
          return esEntity(view.Name);
        }
      }
    }

    /// <summary>
    /// This method can take in a raw table name or view name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sPrefix"/> + name + <see cref="sEntity"/>]
    /// <seealso cref="sPrefix"/><seealso cref="sEntity"/><seealso cref="Entity"/>
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// public class &lt;%=esPlugIn.Entity("my_object")%&gt; : &lt;%=esPlugIn.esEntity("my_object")%&gt;
    /// {
    /// } 
    /// 
    /// // Produces
    /// public class MyObject : esMyObject
    /// {
    /// }
    /// </code>
    /// </example>
    /// <param name="name">Raw string used to build an esEntity or abstact class name</param>
    /// <returns>The esEntity or abstract class name</returns>
    public string esEntity(string name)
    {
      return sPrefix + EntityCore(name) + sEntity;
    }
    #endregion

    #region esCollection

    /// <summary>
    /// Used to create the esCollection or abstract class name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sPrefix"/> + source.Name + <see cref="sCollection"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// public class &lt;%=esPlugIn.Collection(table)%&gt; : &lt;%=esPlugIn.esCollection(table)%&gt;
    /// {
    /// }
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// public class &lt;%=esPlugIn.Collection(view)%&gt; : &lt;%=esPlugIn.esCollection(view)%&gt;
    /// {
    /// } 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The esCollection or abstract class name</returns>
    public string esCollection(esPluginSource source)
    {
      if (source.table != null)
        return esCollection(source.table);
      else
        return esCollection(source.view);
    }

    /// <summary>
    /// Used to create the esCollection or abstract class name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sPrefix"/> + table.Name + <see cref="sCollection"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// public class &lt;%=esPlugIn.Collection(table)%&gt; : &lt;%=esPlugIn.esCollection(table)%&gt;
    /// {
    /// }
    /// 
    /// // Produces
    /// public class EmployeesCollection : esEmployeesCollection
    /// {
    /// }
    /// </code>
    /// </example> 
    /// <param name="table">The ITable to build an esCollection or abstract class name for</param>
    /// <returns>The esCollection or abstract class name</returns>
    public string esCollection(ITable table)
    {
      if (table.Alias != table.Name)
        return sPrefix + Utils.RemoveIllegalCharacters(table.Alias) + sCollection;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return table.Schema + "_" + esCollection(table.Name);
        }
        else
        {
          return esCollection(table.Name);
        }
      }
    }

    /// <summary>
    /// Used to create the esCollection or abstract class name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sPrefix"/> + view.Name + <see cref="sCollection"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// public class &lt;%=esPlugIn.Collection(view)%&gt; : &lt;%=esPlugIn.esCollection(view)%&gt;
    /// {
    /// }
    /// 
    /// // Produces
    /// public class ProductSalesfor1997Collection : esProductSalesfor1997Collection
    /// {
    /// }
    /// </code>
    /// </example> 
    /// <param name="view">The IView to build an esCollection or abstract class name for</param>
    /// <returns>The esCollection or abstract class name</returns>
    public string esCollection(IView view)
    {
      if (view.Alias != view.Name)
        return sPrefix + Utils.RemoveIllegalCharacters(view.Alias) + sCollection;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return view.Schema + "_" + esCollection(view.Name);
        }
        else
        {
          return esCollection(view.Name);
        }
      }
    }

    /// <summary>
    /// This method can take in a raw table name or view name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sPrefix"/> + name + <see cref="sCollection"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// public class &lt;%=esPlugIn.Collection("my_object")%&gt; : &lt;%=esPlugIn.esCollection("my_object")%&gt;
    /// {
    /// } 
    /// 
    /// // Produces
    /// public class MyObjectCollection : esMyObjectCollection
    /// {
    /// }
    /// </code>
    /// </example>
    /// <param name="name">Raw string used to build an esCollection or abstact class name</param>
    /// <returns>The esCollection or abstract class name</returns>
    public string esCollection(string name)
    {
      return sPrefix + EntityCore(name) + sCollection;
    }
    #endregion

    #region esQuery

    /// <summary>
    /// Used to create the esQuery or abstract class name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sPrefix"/> + source.Name + <see cref="sQuery"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// public class &lt;%=esPlugIn.Query(table)%&gt; : &lt;%=esPlugIn.esQuery(table)%&gt;
    /// {
    /// }
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// public class &lt;%=esPlugIn.Query(view)%&gt; : &lt;%=esPlugIn.esQuery(view)%&gt;
    /// {
    /// } 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The esQuery or abstract class name</returns>
    public string esQuery(esPluginSource source)
    {
      if (source.table != null)
        return esQuery(source.table);
      else
        return esQuery(source.view);
    }

    /// <summary>
    /// Used to create the esQuery or abstract class name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sPrefix"/> + table.Name + <see cref="sQuery"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// public class &lt;%=esPlugIn.Query(table)%&gt; : &lt;%=esPlugIn.esQuery(table)%&gt;
    /// {
    /// }
    /// 
    /// // Produces
    /// public class EmployeesQuery : esEmployeesQuery
    /// {
    /// }
    /// </code>
    /// </example> 
    /// <param name="table">The ITable to build an esQuery or abstract class name for</param>
    /// <returns>The esQuery or abstract class name</returns>
    public string esQuery(ITable table)
    {
      if (table.Alias != table.Name)
        return sPrefix + Utils.RemoveIllegalCharacters(table.Alias) + sQuery;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return table.Schema + "_" + esQuery(table.Name);
        }
        else
        {
          return esQuery(table.Name);
        }
      }
    }

    /// <summary>
    /// Used to create the esQuery or abstract class name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sPrefix"/> + view.Name + <see cref="sQuery"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// public class &lt;%=esPlugIn.Query(view)%&gt; : &lt;%=esPlugIn.esQuery(view)%&gt;
    /// {
    /// }
    /// 
    /// // Produces
    /// public class ProductSalesfor1997Query : esProductSalesfor1997Query
    /// {
    /// }
    /// </code>
    /// </example> 
    /// <param name="view">The IView to build an esQuery or abstract class name for</param>
    /// <returns>The esQuery or abstract class name</returns>
    public string esQuery(IView view)
    {
      if (view.Alias != view.Name)
        return sPrefix + Utils.RemoveIllegalCharacters(view.Alias) + sQuery;
      else
      {
        if (Settings.PrefixWithSchema)
        {
          return view.Schema + "_" + esQuery(view.Name);
        }
        else
        {
          return esQuery(view.Name);
        }
      }
    }

    /// <summary>
    /// This method can take in a raw table name or view name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sPrefix"/> + name + <see cref="sQuery"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// public class &lt;%=esPlugIn.Query("my_object")%&gt; : &lt;%=esPlugIn.esQuery("my_object")%&gt;
    /// {
    /// } 
    /// 
    /// // Produces
    /// public class MyObjectQuery : esMyObjectQuery
    /// {
    /// }
    /// </code>
    /// </example>
    /// <param name="name">Raw string used to build an esQuery or abstact class name</param>
    /// <returns>The esQuery or abstract class name</returns>
    public string esQuery(string name)
    {
      return sPrefix + EntityCore(name) + sQuery;
    }
    #endregion

    #endregion

    #region Property Access

    #region PropertyName

    /// <summary>
    /// Used to derive a Property Name for a column.
    /// </summary>
    /// <remarks>Unless <see cref="UseRawNames"/> is checked the Utils.SetPascalCase() method is used on IColumn.Name</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// foreach(IColumn col in table.Columns)
    /// {
    ///     &lt;%=esPlugIn.NullableType(col)%&gt; &lt;%=esPlugIn.PropertyName(col)%&gt; &lt;%=esPlugIn.ParameterName(col)%&gt;;
    /// }    
    /// 
    /// // The code above produces
    /// System.Int32? EmployeeID employeeID;
    /// System.String LastName lastName;
    /// System.String FirstName firstName;
    /// DateTime? HireDate hireDate;
    /// ...
    /// </code>
    /// </example>
    /// <param name="column"></param>
    /// <returns></returns>
    public string PropertyName(IColumn column)
    {
      if (column.Alias != column.Name)
        return column.Alias;
      else
        return PropertyName(column.Name);
    }

    /// <summary>
    /// Used to derive a Property Name for a column.
    /// </summary>
    /// <remarks>Unless <see cref="UseRawNames"/> is checked the Utils.SetPascalCase() method is used on name</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    ///  string name = &lt;%=esPlugIn.PropertyName("my_column")%&gt;;
    ///  
    /// // The code above produces
    /// string name = "MyColumn";
    /// </code>
    /// </example>
    /// <param name="name">Raw string name of a column</param>
    /// <returns></returns>
    public string PropertyName(string name)
    {
      return ToPascalCase(name);
    }
    #endregion

    #region ParameterName

    /// <summary>
    /// Used to derive a parameter name (usually the PropertyName in camel case) for a column.
    /// </summary>
    /// <remarks>Unless <see cref="UseRawNames"/> is checked the Utils.SetCamelCase() method is used on name.
    /// If UseRawNames is checked then this formula is used:  "_" + Utils.TrimSpaces(IColumn.Name, <see cref="sTrimList"/>) </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// foreach(IColumn col in table.Columns)
    /// {
    ///     &lt;%=esPlugIn.NullableType(col)%&gt; &lt;%=esPlugIn.PropertyName(col)%&gt; &lt;%=esPlugIn.ParameterName(col)%&gt;;
    /// }    
    /// 
    /// // The code above produces
    /// System.Int32? EmployeeID employeeID;
    /// System.String LastName lastName;
    /// System.String FirstName firstName;
    /// DateTime? HireDate hireDate;
    /// ...
    /// </code>
    /// </example>
    /// <param name="column">IColumn for which the PropertyName is needed</param>
    /// <returns></returns>
    public string ParameterName(IColumn column)
    {
      // In this case we always call down so that the
      // PropertyName and ParameterName wont match
      return ParameterName(column.Alias);
    }

    /// <summary>
    /// Used to derive a parameter name (usually the PropertyName in camel case) for a column.
    /// </summary>
    /// <remarks>Unless <see cref="UseRawNames"/> is checked the Utils.SetCamelCase() method is used on name.
    /// If UseRawNames is checked then this formula is used:  "_" + Utils.TrimSpaces(name, <see cref="sTrimList"/>) </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    ///  string name = &lt;%=esPlugIn.ParameterName("my_column")%&gt;;
    ///  
    /// // The code above produces
    /// string name = "myColumn";
    /// </code>
    /// </example>
    /// <param name="name">Raw string name of a column</param>
    /// <returns></returns>
    public string ParameterName(string name)
    {
      return ToCamelCase(name);
    }
    #endregion

    #endregion

    #region Stored Procedures

    #region Insert

    /// <summary>
    /// Used to create the Insert stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + source.Name + <see cref="sProcInsert"/> + <see cref="sProcSuffix"/>]
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// &lt;%=esPlugIn.ProcInsert(source)%&gt;
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// &lt;%=esPlugIn.ProcInsert(source)%&gt; 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The Insert stored procedure name</returns>
    public string ProcInsert(esPluginSource source)
    {
      if (source.table != null)
        return ProcInsert(source.table);
      else
        return ProcInsert(source.view);
    }

    /// <summary>
    /// Used to create the Insert stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + table.Name + <see cref="sProcInsert"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.ProcInsert(table)%&gt;
    /// </code>
    /// </example> 
    /// <param name="table">The ITable to use in generating the Insert stored procedure name</param>
    /// <returns>The Insert stored procedure name</returns>
    public string ProcInsert(ITable table)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcInsert + table.Name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + table.Name + Settings.ProcInsert + Settings.ProcSuffix;
      }
    }

    /// <summary>
    /// Used to create the Insert stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + view.Name + <see cref="sProcInsert"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// &lt;%=esPlugIn.ProcInsert(view)%&gt; 
    /// </code>
    /// </example> 
    /// <param name="view">The IView to use in generating the Insert stored procedure name</param>
    /// <returns>The Insert stored procedure name</returns>
    public string ProcInsert(IView view)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcInsert + view.Name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + view.Name + Settings.ProcInsert + Settings.ProcSuffix;
      }
    }

    /// <summary>
    /// Used to create the Insert stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + name + <see cref="sProcInsert"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.ProcInsert("my_table_name")%&gt;
    /// </code>
    /// </example> 
    /// <param name="name">The source name to use in generating the Insert stored procedure name</param>
    /// <returns>The Insert stored procedure name</returns>
    public string ProcInsert(string name)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcInsert + name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + name + Settings.ProcInsert + Settings.ProcSuffix;
      }
    }

    #endregion

    #region Update

    /// <summary>
    /// Used to create the Update stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + source.Name + <see cref="sProcUpdate"/> + <see cref="sProcSuffix"/>]
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// &lt;%=esPlugIn.ProcUpdate(source)%&gt;
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// &lt;%=esPlugIn.ProcUpdate(source)%&gt; 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The Update stored procedure name</returns>
    public string ProcUpdate(esPluginSource source)
    {
      if (source.table != null)
        return ProcUpdate(source.table);
      else
        return ProcUpdate(source.view);
    }

    /// <summary>
    /// Used to create the ProcUpdate stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + table.Name + <see cref="sProcUpdate"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.ProcUpdate(table)%&gt;
    /// </code>
    /// </example> 
    /// <param name="table">The ITable to use in generating the Update stored procedure name</param>
    /// <returns>The Update stored procedure name</returns>
    public string ProcUpdate(ITable table)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcUpdate + table.Name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + table.Name + Settings.ProcUpdate + Settings.ProcSuffix;
      }
    }

    /// <summary>
    /// Used to create the Update stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + view.Name + <see cref="sProcUpdate"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// &lt;%=esPlugIn.ProcUpdate(view)%&gt; 
    /// </code>
    /// </example> 
    /// <param name="view">The IView to use in generating the Update stored procedure name</param>
    /// <returns>The Update stored procedure name</returns>
    public string ProcUpdate(IView view)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcUpdate + view.Name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + view.Name + Settings.ProcUpdate + Settings.ProcSuffix;
      }
    }

    /// <summary>
    /// Used to create the Update stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + name + <see cref="sProcUpdate"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.ProcUpdate("my_table_name")%&gt;
    /// </code>
    /// </example> 
    /// <param name="name">The source name to use in generating the Update stored procedure name</param>
    /// <returns>The Update stored procedure name</returns>
    public string ProcUpdate(string name)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcUpdate + name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + name + Settings.ProcUpdate + Settings.ProcSuffix;
      }
    }

    #endregion

    #region Delete

    /// <summary>
    /// Used to create the Delete stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + source.Name + <see cref="sProcDelete"/> + <see cref="sProcSuffix"/>]
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// &lt;%=esPlugIn.ProcDelete(source)%&gt;
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// &lt;%=esPlugIn.ProcDelete(source)%&gt; 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The Delete stored procedure name</returns>
    public string ProcDelete(esPluginSource source)
    {
      if (source.table != null)
        return ProcDelete(source.table);
      else
        return ProcDelete(source.view);
    }

    /// <summary>
    /// Used to create the Delete stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + table.Name + <see cref="sProcDelete"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.ProcDelete(table)%&gt;
    /// </code>
    /// </example> 
    /// <param name="table">The ITable to use in generating the Delete stored procedure name</param>
    /// <returns>The Delete stored procedure name</returns>
    public string ProcDelete(ITable table)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcDelete + table.Name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + table.Name + Settings.ProcDelete + Settings.ProcSuffix;
      }
    }

    /// <summary>
    /// Used to create the Delete stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + view.Name + <see cref="sProcDelete"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// &lt;%=esPlugIn.ProcDelete(view)%&gt; 
    /// </code>
    /// </example> 
    /// <param name="view">The IView to use in generating the Delete stored procedure name</param>
    /// <returns>The Delete stored procedure name</returns>
    public string ProcDelete(IView view)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcDelete + view.Name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + view.Name + Settings.ProcDelete + Settings.ProcSuffix;
      }
    }

    /// <summary>
    /// Used to create the Delete stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + name + <see cref="sProcDelete"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.ProcDelete("my_table_name")%&gt;
    /// </code>
    /// </example> 
    /// <param name="name">The source name to use in generating the Delete stored procedure name</param>
    /// <returns>The Delete stored procedure name</returns>
    public string ProcDelete(string name)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcDelete + name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + name + Settings.ProcDelete + Settings.ProcSuffix;
      }
    }

    #endregion

    #region LoadAll

    /// <summary>
    /// Used to create the LoadAll stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + source.Name + <see cref="sProcLoadAll"/> + <see cref="sProcSuffix"/>]
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// &lt;%=esPlugIn.ProcLoadAll(source)%&gt;
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// &lt;%=esPlugIn.ProcLoadAll(source)%&gt; 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The LoadAll stored procedure name</returns>
    public string ProcLoadAll(esPluginSource source)
    {
      if (source.table != null)
        return ProcLoadAll(source.table);
      else
        return ProcLoadAll(source.view);
    }

    /// <summary>
    /// Used to create the LoadAll stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + table.Name + <see cref="sProcLoadAll"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.ProcLoadAll(table)%&gt;
    /// </code>
    /// </example> 
    /// <param name="table">The ITable to use in generating the LoadAll stored procedure name</param>
    /// <returns>The LoadAll stored procedure name</returns>
    public string ProcLoadAll(ITable table)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcLoadAll + table.Name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + table.Name + Settings.ProcLoadAll + Settings.ProcSuffix;
      }
    }

    /// <summary>
    /// Used to create the LoadAll stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + view.Name + <see cref="sProcLoadAll"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// &lt;%=esPlugIn.ProcLoadAll(view)%&gt; 
    /// </code>
    /// </example> 
    /// <param name="view">The IView to use in generating the LoadAll stored procedure name</param>
    /// <returns>The LoadAll stored procedure name</returns>
    public string ProcLoadAll(IView view)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcLoadAll + view.Name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + view.Name + Settings.ProcLoadAll + Settings.ProcSuffix;
      }
    }

    /// <summary>
    /// Used to create the LoadAll stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + name + <see cref="sProcLoadAll"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.ProcLoadAll("my_table_name")%&gt;
    /// </code>
    /// </example> 
    /// <param name="name">The source name to use in generating the LoadAll stored procedure name</param>
    /// <returns>The LoadAll stored procedure name</returns>
    public string ProcLoadAll(string name)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcLoadAll + name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + name + Settings.ProcLoadAll + Settings.ProcSuffix;
      }
    }

    #endregion

    #region LoadByPK

    /// <summary>
    /// Used to create the LoadByPK stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + source.Name + <see cref="sProcLoadByPK"/> + <see cref="sProcSuffix"/>]
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(table, null);
    /// &lt;%=esPlugIn.ProcLoadByPK(source)%&gt;
    /// 
    /// // or
    /// 
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// EntitySpaces.PlugIn.esPluginSource source = new EntitySpaces.PlugIn.esPluginSource(null, view);
    /// &lt;%=esPlugIn.ProcLoadByPK(source)%&gt; 
    /// </code>
    /// </example> 
    /// <param name="source">Use this method to write templates that operate on ITable/IView transparently</param>
    /// <returns>The LoadByPK stored procedure name</returns>
    public string ProcLoadByPK(esPluginSource source)
    {
      if (source.table != null)
        return ProcLoadByPK(source.table);
      else
        return ProcLoadByPK(source.view);
    }

    /// <summary>
    /// Used to create the LoadByPK stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + table.Name + <see cref="sProcLoadByPK"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.ProcLoadByPK(table)%&gt;
    /// </code>
    /// </example> 
    /// <param name="table">The ITable to use in generating the LoadByPK stored procedure name</param>
    /// <returns>The LoadByPK stored procedure name</returns>
    public string ProcLoadByPK(ITable table)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcLoadByPK + table.Name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + table.Name + Settings.ProcLoadByPK + Settings.ProcSuffix;
      }
    }

    /// <summary>
    /// Used to create the LoadByPK stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + view.Name + <see cref="sProcLoadByPK"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// IView view = MyMeta.Databases["Northwind"].Views["Product Sales for 1997"];
    /// &lt;%=esPlugIn.ProcLoadByPK(view)%&gt; 
    /// </code>
    /// </example> 
    /// <param name="view">The IView to use in generating the LoadByPK stored procedure name</param>
    /// <returns>The LoadByPK stored procedure name</returns>
    public string ProcLoadByPK(IView view)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcLoadByPK + view.Name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + view.Name + Settings.ProcLoadByPK + Settings.ProcSuffix;
      }
    }

    /// <summary>
    /// Used to create the LoadByPK stored procedure name.
    /// </summary>
    /// <remarks>Formula = [<see cref="sProcPrefix"/> + name + <see cref="sProcLoadByPK"/> + <see cref="sProcSuffix"/>]</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// &lt;%=esPlugIn.ProcLoadByPK("my_table_name")%&gt;
    /// </code>
    /// </example> 
    /// <param name="name">The source name to use in generating the LoadByPK stored procedure name</param>
    /// <returns>The LoadByPK stored procedure name</returns>
    public string ProcLoadByPK(string name)
    {
      if (Settings.ProcVerbFirst)
      {
        return Settings.ProcPrefix + Settings.ProcLoadByPK + name + Settings.ProcSuffix;

      }
      else
      {
        return Settings.ProcPrefix + name + Settings.ProcLoadByPK + Settings.ProcSuffix;
      }
    }

    #endregion

    #endregion

    #region Hierarchical

    /// <summary>
    /// Used when building Parent relational object names. 
    /// </summary>
    /// <remarks>
    /// The default is "UpTo".
    /// </remarks>
    public string sUpToPrefix => "UpTo";

    /// <summary>
    /// Used when building an Entity relational object name. 
    /// </summary>
    /// <remarks>
    /// The default is "".
    /// </remarks>
    public string sOnePrefix => Settings.OnePrefix;

    /// <summary>
    /// Used when building an Entity relational object name. 
    /// </summary>
    /// <remarks>
    /// The default is "By".
    /// </remarks>
    public string sOneSep => Settings.OneSeparator;

    /// <summary>
    /// Used when building an Entity relational object name. 
    /// </summary>
    /// <remarks>
    /// The default is "".
    /// The suffix always follows the table name,
    /// even if Swap Names is checked.
    /// </remarks>
    public string sOneSuffix => Settings.OneSuffix;

    /// <summary>
    /// Used when building a Collection relational object name. 
    /// </summary>
    /// <remarks>
    /// The default is "".
    /// </remarks>
    public string sManyPrefix => Settings.ManyPrefix;

    /// <summary>
    /// Used when building a Collection relational object name. 
    /// </summary>
    /// <remarks>
    /// The default is "By".
    /// </remarks>
    public string sManySep => Settings.ManySeparator;

    /// <summary>
    /// Used when building a Collection relational object name. 
    /// </summary>
    /// <remarks>
    /// The default is "Collection".
    /// The suffix always follows the table name,
    /// even if Swap Names is checked.
    /// </remarks>
    public string sManySuffix => Settings.ManySuffix;

    /// <summary>
    /// Only add suffixes to self-referencing relational object names. 
    /// </summary>
    /// <remarks>
    /// The default is false.
    /// </remarks>
    public bool SelfOnly => Settings.SelfOnly;

    /// <summary>
    /// Swap the table name and foreign column name when creating relational object names. 
    /// </summary>
    /// <remarks>
    /// The default is false.
    /// </remarks>
    public bool SwapNames => Settings.SwapNames;

    /// <summary>
    /// Use the associative table name for complex relationships.
    /// The associative table name is used in place of the foreign
    /// column name as a tie breaker for ManyToMany.
    /// </summary>
    /// <remarks>
    /// The default is false.
    /// This must be set to true if the database has more than one
    /// ManyToMany between the same two tables.
    /// </remarks>
    /// <example>
    /// If set to true (for multiple ManyToMany)
    /// <code>
    /// TerritoriesCollection terrColl = emp.TerritoriesCollectionByEmployeeTerritories;
    /// </code>
    /// If set to false (the default)
    /// <code>
    /// TerritoriesCollection terrColl = emp.TerritoriesCollection;
    /// </code>
    /// </example>
    public bool UseAssociativeName => Settings.UseAssociativeName;

    /// <summary>
    /// Prefix Prent names with "UpTo".
    /// This help distinguish which direction in the
    /// hierarchical tree is being traversed.
    /// EntitySpaces currently only saves down the tree.
    /// </summary>
    /// <remarks>
    /// The default is true.
    /// </remarks>
    /// <example>
    /// If set to true (the default)
    /// <code>
    /// Suppliers sup = prd.UpToSuppliersBySupplierID;
    /// </code>
    /// If set to false
    /// <code>
    /// Suppliers sup = prd.SuppliersBySupplierID;
    /// </code>
    /// </example>
    public bool UseUpToPrefix => Settings.UseUpToPrefix;

    /// <summary>
    /// The relational object name for an Entity. 
    /// </summary>
    /// <remarks>
    /// The relational object name for a one-to-one. 
    /// For example, the Group table has a CustomerGroup
    /// relational object name.
    /// If SelfOnly is false, then the Entity suffix is appended.
    /// </remarks>
    public string EntityRelationName(ITable table)
    {
      var suffix = "";
      if (!SelfOnly)
      {
        suffix = sOneSuffix;
      }
      return sOnePrefix + Entity(table) + suffix;
    }

    /// <summary>
    /// The relational object name for an Entity. 
    /// </summary>
    /// <remarks>
    /// The relational object name for a many-to-one. 
    /// For example, the Customer table has an EmployeeByStaffAssigned
    /// relational object name for the StaffAssigned column.
    /// If SelfOnly is false, then the Entity suffix is appended.
    /// If it is a self-reference then the Entity suffix is appended.
    /// </remarks>
    public string EntityRelationName(ITable table, IColumn col, bool isSelfReference)
    {
      var suffix = "";
      if (!SelfOnly || isSelfReference)
      {
        suffix = sOneSuffix;
      }

      string resultName;
      
      if (SwapNames)
      {
          resultName = sOnePrefix + PropertyName(col) + sOneSep + Entity(table) + suffix;
      }
      else
      {
          resultName = sOnePrefix + Entity(table) + suffix + sOneSep + PropertyName(col);
      }

      return resultName;
    }

    /// <summary>
    /// The relational object name for a Collection. 
    /// </summary>
    /// <remarks>
    /// The relational object name for a many-to-many. 
    /// For example, the Employees table has a TerritoriesCollectionByEmployeeTerritories
    /// relational object name.
    /// If SelfOnly is true, then the Collection suffix is dropped.
    /// If UseAssociativeName is false, then ByEmployeeTerritories is dropped.
    /// </remarks>
    public string CollectionRelationName(ITable table, ITable associativeTable)
    {
      var suffix = "";
      if (!SelfOnly)
      {
        suffix = sManySuffix;
      }

      string resultName;
      if (UseAssociativeName)
      {
          resultName = sManyPrefix + Entity(table) + suffix + sManySep + Entity(associativeTable);
      }
      else
      {
          resultName = sManyPrefix + Entity(table) + suffix;
      }
      return resultName;
    }

    /// <summary>
    /// Obsolete. The relational object name for a Collection. 
    /// Provided for backwards compatibility.
    /// </summary>
    /// <remarks>
    /// The relational object name for a many-to-many. 
    /// For example, the Employees table has a TerritoriesCollectionByEmployeeTerritories
    /// relational object name.
    /// If SelfOnly is true, then the Collection suffix is dropped.
    /// This overload ignores the new UseAssociativeName flag.
    /// </remarks>
    public string CollectionRelationName(ITable table)
    {
      var suffix = "";
      if (!SelfOnly)
      {
        suffix = sManySuffix;
      }
      var resultName = sManyPrefix + Entity(table) + suffix;
      return resultName;
    }

    /// <summary>
    /// The relational object name for a Collection. 
    /// </summary>
    /// <remarks>
    /// The relational object name for a zero-to-many. 
    /// For example, the Employee table has an OrderCollectionByEmployeeID
    /// relational object name.
    /// If SelfOnly is false, then the Collection suffix is appended.
    /// If it is a self-reference then the Collection suffix is appended.
    /// </remarks>
    public string CollectionRelationName(ITable table, IColumn col, bool isSelfReference)
    {
      var suffix = "";
      if (!SelfOnly || isSelfReference)
      {
        suffix = sManySuffix;
      }

      string resultName;

      if (SwapNames)
      {
          resultName = sManyPrefix + PropertyName(col) + sManySep + Entity(table) + suffix;
      }
      else
      {
          resultName = sManyPrefix + Entity(table) + suffix + sManySep + PropertyName(col);
      }
      
      return resultName;

    }

    /// <summary>
    /// Returns true if the TableRelation for the foreign key
    /// is down stream from current table. 
    /// </summary>
    /// <remarks>
    /// True for zero to many.
    /// True for one side of a one to one, where
    /// the foreign table is the one with the FK constraint defined.
    /// </remarks>
    public bool IsDownStream(TableRelation tr)
    {
      if (tr.IsOneToOne && !tr.IsDirect)
      {
        return true;
      }

      if (tr.IsZeroToMany)
      {
        return true;
      }

      return false;
    }

    /// <summary>
    /// Returns the hierarchical object name of a foreign key table relation
    /// for the down stream hierarchical property
    /// </summary>
    /// <remarks>
    /// For example, EmployeesCollectionByReportsTo.
    /// </remarks>
    public string DownStreamObjectName(TableRelation tr)
    {
      if (tr.IsOneToOne && !tr.IsDirect)
      {
        return EntityRelationName(tr.ForeignTable);
      }

      if (tr.IsZeroToMany)
      {
        if (tr.IsSelfReference)
        {
          return CollectionRelationName(tr.ForeignTable, tr.PrimaryColumns[0], tr.IsSelfReference);
        }
        else
        {
          return CollectionRelationName(tr.ForeignTable, tr.ForeignColumns[0], tr.IsSelfReference);
        }
      }

      return null;
    }

    /// <summary>
    /// Returns the hierarchical object name of a foreign key table relation
    /// for the up stream hierarchical property
    /// </summary>
    /// <remarks>
    /// For example, UpToEmployeesByReportsTo.
    /// </remarks>
    public string UpStreamObjectName(TableRelation tr)
    {
      if (tr.IsOneToOne && tr.IsDirect)
      {
        return sUpToPrefix + EntityRelationName(tr.ForeignTable);
      }

      if (tr.IsManyToMany)
      {
        if (tr.ForeignTable.PrimaryKeys.Count == 2)
        {
          return sUpToPrefix + CollectionRelationName(tr.CrossReferenceTable, tr.ForeignTable);
        }
      }

      if (tr.IsManyToOne)
      {
        return sUpToPrefix + EntityRelationName(tr.ForeignTable, tr.PrimaryColumns[0], tr.IsSelfReference);
      }

      return null;
    }

    /// <summary>
    /// Returns the hierarchical object type of a foreign key table relation
    /// for down stream hierarchical properties.
    /// </summary>
    /// <remarks>
    /// For example, EmployeesColectionByReportsTo has an object type of
    /// Employees.
    /// </remarks>
    public string DownStreamObjectType(TableRelation tr)
    {
      if (tr.IsOneToOne && !tr.IsDirect)
      {
        return Entity(tr.ForeignTable);
      }

      if (tr.IsZeroToMany)
      {
        return Entity(tr.ForeignTable);
      }

      return null;
    }

    /// <summary>
    /// Returns the hierarchical object type of a foreign key table relation
    /// for up stream hierarchical properties.
    /// </summary>
    /// <remarks>
    /// For example, UpToEmployeesByReportsTo has an object type of
    /// Employees.
    /// </remarks>
    public string UpStreamObjectType(TableRelation tr)
    {
      if (tr.IsOneToOne && tr.IsDirect)
      {
        return Entity(tr.ForeignTable);
      }

      if (tr.IsManyToMany)
      {
        if (tr.ForeignTable.PrimaryKeys.Count == 2)
        {
          return Entity(tr.CrossReferenceTable);
        }
      }

      if (tr.IsManyToOne)
      {
        return Entity(tr.ForeignTable);
      }

      return null;
    }

    #endregion

    #region Miscellaneous

    /// <summary>
    /// The Version Number of EntitySpace.Core and EntitySpaces.Interfaces
    /// </summary>
    public string esVersion => "2024.1.4.0";

    /// <summary>
    /// The database driver specified in the Settings file.
    /// </summary>
    public string esDriver => Settings.Driver;

    /// <summary>
    /// Trims the characters in TrimList including spaces from the string passed in and
    /// returns the result.
    /// </summary>
    /// <param name="theString">The string to trim</param>
    /// <returns>The newly trimmed string</returns>
    public string Trim(string theString)
    {
      return Utils.RemoveIllegalCharacters(theString);
    }

    /// <summary>
    /// Converts C# built in types to the corresponding NET Framework System Type 
    /// </summary>
    /// <remarks>Use this whenever you need a .NET System Type</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// foreach(IColumn col in table.Columns)
    /// {
    ///     &lt;%=esPlugIn.CSharpToSystemType(col)%&gt;
    /// }   
    /// </code>
    /// </example>
    /// <param name="col"></param>
    /// <returns></returns>
    public static string CSharpToSystemType(IColumn col)
    {
      return CSharpToSystemType(col.LanguageType);
    }

    /// <summary>
    /// Converts C# built in types to the corresponding NET Framework System Type 
    /// </summary>
    /// <remarks>Use this whenever you need a .NET System Type</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// foreach(IColumn col in table.Columns)
    /// {
    ///     &lt;%=esPlugIn.CSharpToSystemType(col.LanguageType)%&gt;
    /// }   
    /// </code>
    /// </example>
    /// <param name="csharpType"></param>
    /// <returns></returns>
    public static string CSharpToSystemType(string csharpType)
    {
      switch (csharpType)
      {
        case "bool": return "System.Boolean";
        case "byte": return "System.Byte";
        case "sbyte": return "System.SByte";
        case "char": return "System.Char";
        case "decimal": return "System.Decimal";
        case "double": return "System.Double";
        case "float": return "System.Single";
        case "int": return "System.Int32";
        case "uint": return "System.UInt32";
        case "long": return "System.Int64";
        case "ulong": return "System.UInt64";
        case "object": return "System.Object";
        case "short": return "System.Int16";
        case "ushort": return "System.UInt16";
        case "string": return "System.String";
        case "DateTime": return "System.DateTime";
        case "DateTimeOffset": return "System.DateTimeOffset";
        case "TimeSpan": return "System.TimeSpan";
        case "Guid": return "System.Guid";

        case "bool[]": return "System.Boolean[]";
        case "byte[]": return "System.Byte[]";
        case "sbyte[]": return "System.SByte[]";
        case "char[]": return "System.Char[]";
        case "decimal[]": return "System.Decimal[]";
        case "double[]": return "System.Double[]";
        case "float[]": return "System.Single[]";
        case "int[]": return "System.Int32[]";
        case "uint[]": return "System.UInt32[]";
        case "long[]": return "System.Int64[]";
        case "ulong[]": return "System.UInt64[]";
        case "object[]": return "System.Object[]";
        case "short[]": return "System.Int16[]";
        case "ushort[]": return "System.UInt16[]";
        case "string[]": return "System.String[]";
        case "DateTime[]": return "System.DateTime[]";
        case "DateTimeOffset[]": return "System.DateTimeOffset[]";
        case "TimeSpan[]": return "System.TimeSpan[]";
        case "Guid[]": return "System.Guid[]";

        default:
          return csharpType;
      }
    }

    /// <summary>
    /// Converts VB.NET built in types to the corresponding NET Framework System Type 
    /// </summary>
    /// <remarks>Use this whenever you need a .NET System Type</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// foreach(IColumn col in table.Columns)
    /// {
    ///     &lt;%=esPlugIn.VBToSystemType(col)%&gt;
    /// }   
    /// </code>
    /// </example>
    /// <param name="col"></param>
    /// <returns></returns>
    public string VBToSystemType(IColumn col)
    {
      return VBToSystemType(col.LanguageType);
    }

    /// <summary>
    /// Converts VB.NET built in types to the corresponding NET Framework System Type 
    /// </summary>
    /// <remarks>Use this whenever you need a .NET System Type</remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// foreach(IColumn col in table.Columns)
    /// {
    ///     &lt;%=esPlugIn.VBToSystemType(col.LanguageType)%&gt;
    /// }   
    /// </code>
    /// </example>
    /// <param name="csharpType"></param>
    /// <returns></returns>
    public string VBToSystemType(string csharpType)
    {
      switch (csharpType)
      {
        case "bool": return "System.Boolean";
        case "byte": return "System.Byte";
        case "sbyte": return "System.SByte";
        case "char": return "System.Char";
        case "decimal": return "System.Decimal";
        case "double": return "System.Double";
        case "float": return "System.Single";
        case "int": return "System.Int32";
        case "uint": return "System.UInt32";
        case "long": return "System.Int64";
        case "ulong": return "System.UInt64";
        case "object": return "System.Object";
        case "short": return "System.Int16";
        case "ushort": return "System.UInt16";
        case "string": return "System.String";
        case "DateTime": return "System.DateTime";
        case "DateTimeOffset": return "System.DateTimeOffset";
        case "TimeSpan": return "System.TimeSpan";
        case "Guid": return "System.Guid";

        case "bool[]": return "System.Boolean()";
        case "byte[]": return "System.Byte()";
        case "sbyte[]": return "System.SByte()";
        case "char[]": return "System.Char()";
        case "decimal[]": return "System.Decimal()";
        case "double[]": return "System.Double()";
        case "float[]": return "System.Single()";
        case "int[]": return "System.Int32()";
        case "uint[]": return "System.UInt32()";
        case "long[]": return "System.Int64()";
        case "ulong[]": return "System.UInt64()";
        case "object[]": return "System.Object()";
        case "short[]": return "System.Int16()";
        case "ushort[]": return "System.UInt16()";
        case "string[]": return "System.String()";
        case "DateTime[]": return "System.DateTime()";
        case "DateTimeOffset[]": return "System.DateTimeOffset()";
        case "TimeSpan[]": return "System.TimeSpan()";
        case "Guid[]": return "System.Guid()";

        default:
          return csharpType;
      }
    }


    /// <summary>
    /// Returns the .NET System Type for the column.
    /// </summary>
    /// <remarks>Use this whenever you need a .NET System Type for a <see cref="PropertyName"/> or <see cref="ParameterName"/></remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// foreach(IColumn col in table.Columns)
    /// {
    ///     &lt;%=esPlugIn.NullableType(col)%&gt; &lt;%=esPlugIn.PropertyName(col)%&gt; &lt;%=esPlugIn.ParameterName(col)%&gt;;
    /// }    
    /// 
    /// // The code above produces
    /// System.Int32? EmployeeID employeeID;
    /// System.String LastName lastName;
    /// System.String FirstName firstName;
    /// DateTime? HireDate hireDate;
    /// ...
    /// </code>
    /// </example>
    /// <param name="column"></param>
    /// <returns></returns>
    public string NullableType(IColumn column)
    {
      var newType = CSharpToSystemType(column.LanguageType);

      switch (newType)
      {
        case "System.Char":
        case "System.Int16":
        case "System.Int32":
        case "System.Int64":
        case "System.UInt16":
        case "System.UInt32":
        case "System.UInt64":
        case "System.Boolean":
        case "System.DateTime":
        case "System.DateTimeOffset":
        case "System.TimeSpan":
        case "System.Decimal":
        case "System.Double":
        case "System.Byte":
        case "System.SByte":
        case "System.Single":
        case "System.Guid":

          if (Settings.UseNullableTypesAlways || column.IsNullable)
            newType += "?";
          break;
      }

      return newType;
    }

    /// <summary>
    /// Returns the .NET System Type for the column.
    /// </summary>
    /// <remarks>Use this whenever you need a .NET System Type for a <see cref="PropertyName"/> or <see cref="ParameterName"/></remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    ///  string type = "&lt;%=esPlugIn.NullableType("System.Int32")%&gt;";
    ///  
    /// // The code above produces
    /// string type = "System.Int32?";
    /// </code>
    /// </example>
    /// <param name="type"></param>
    /// <returns></returns>
    public string NullableType(string type)
    {
      var newType = CSharpToSystemType(type);

      switch (newType)
      {
        case "System.Char":
        case "System.Int16":
        case "System.Int32":
        case "System.Int64":
        case "System.UInt16":
        case "System.UInt32":
        case "System.UInt64":
        case "System.Boolean":
        case "System.DateTime":
        case "System.DateTimeOffset":
        case "System.TimeSpan":
        case "System.Decimal":
        case "System.Double":
        case "System.Byte":
        case "System.SByte":
        case "System.Single":
        case "System.Guid":
          newType += "?";
          break;
      }

      return newType;
    }

    /// <summary>
    /// Returns the .NET System Type for the column, wraps nullable types
    /// </summary>
    /// <remarks>Use this whenever you need a .NET System Type for a <see cref="PropertyName"/> or <see cref="ParameterName"/></remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// foreach(IColumn col in table.Columns)
    /// {
    ///     &lt;%=esPlugIn.NullableTypeVB(col)%&gt; &lt;%=esPlugIn.PropertyName(col)%&gt; &lt;%=esPlugIn.ParameterName(col)%&gt;;
    /// }    
    /// 
    /// // The code above produces
    /// Nullable(Of System.Int32) EmployeeID employeeID;
    /// System.String LastName lastName;
    /// System.String FirstName firstName;
    /// Nullable(Of DateTime HireDate hireDate;
    /// ...
    /// </code>
    /// </example>
    /// <param name="column"></param>
    /// <returns></returns>
    public string NullableTypeVB(IColumn column)
    {
      var newType = CSharpToSystemType(column.LanguageType);

      switch (newType)
      {
        case "System.Char":
        case "System.Int16":
        case "System.Int32":
        case "System.Int64":
        case "System.UInt16":
        case "System.UInt32":
        case "System.UInt64":
        case "System.Boolean":
        case "System.DateTime":
        case "System.DateTimeOffset":
        case "System.TimeSpan":
        case "System.Decimal":
        case "System.Double":
        case "System.Byte":
        case "System.SByte":
        case "System.Single":
        case "System.Guid":

          if (Settings.UseNullableTypesAlways || column.IsNullable)
            newType = "Nullable(Of " + newType + ")";
          break;

        default:
          newType = newType.Replace("[]", "()");
          break;
      }

      return newType;
    }

    /// <summary>
    /// Returns the .NET System Type for the column, specifically wraps nullable types
    /// </summary>
    /// <remarks>Use this whenever you need a .NET System Type for a <see cref="PropertyName"/> or <see cref="ParameterName"/></remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    ///  string type = "&lt;%=esPlugIn.NullableTypeVB("System.Int32")%&gt;";
    ///  
    /// // The code above produces
    /// string type = "Nullable(Of System.Int32)";
    /// </code>
    /// </example>
    /// <param name="type"></param>
    /// <returns></returns>
    public string NullableTypeVB(string type)
    {
      var newType = CSharpToSystemType(type);

      switch (newType)
      {
        case "System.Char":
        case "System.Int16":
        case "System.Int32":
        case "System.Int64":
        case "System.UInt16":
        case "System.UInt32":
        case "System.UInt64":
        case "System.Boolean":
        case "System.DateTime":
        case "System.DateTimeOffset":
        case "System.TimeSpan":
        case "System.Decimal":
        case "System.Double":
        case "System.Byte":
        case "System.SByte":
        case "System.Single":
        case "System.Guid":
          newType = "Nullable(Of " + newType + ")";
          break;

        default:
          return newType.Replace("[]", "()");
      }

      return newType;
    }

    /// <summary>
    /// Returns the EntitySpaces.Interfaces.esSystemType for the IColumn.LanguageType
    /// </summary>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// foreach(IColumn col in table.Columns)
    /// {
    ///     if(esPlugIn.IsArrayType(col))
    ///     {
    ///			&lt;%=col.Name%&gt; = &lt;%=col.LanguageType%&gt; = &lt;%=col.NullableType(col)%&gt;
    ///     }
    /// }    
    /// 
    /// // The code above produces
    /// Photo = image = System.Byte[]
    /// </code>
    /// </example>
    /// <param name="column"></param>
    /// <returns></returns>
    public string esSystemType(IColumn column)
    {
      var theType = CSharpToSystemType(column);

      switch (theType)
      {
        case "System.Boolean": return "esSystemType.Boolean";
        case "System.Byte": return "esSystemType.Byte";
        case "System.SByte": return "esSystemType.SByte";
        case "System.Char": return "esSystemType.Char";
        case "System.Decimal": return "esSystemType.Decimal";
        case "System.Double": return "esSystemType.Double";
        case "System.Single": return "esSystemType.Single";
        case "System.Int32": return "esSystemType.Int32";
        case "System.UInt32": return "esSystemType.UInt32";
        case "System.Int64": return "esSystemType.Int64";
        case "System.UInt64": return "esSystemType.UInt64";
        case "System.Object": return "esSystemType.Object";
        case "System.Int16": return "esSystemType.Int16";
        case "System.UInt16": return "esSystemType.UInt16";
        case "System.String": return "esSystemType.String";
        case "System.DateTime": return "esSystemType.DateTime";
        case "System.DateTimeOffset": return "esSystemType.DateTimeOffset";
        case "System.TimeSpan": return "esSystemType.TimeSpan";
        case "System.Guid": return "esSystemType.Guid";

        case "System.Boolean[]": return "esSystemType.BooleanArray";
        case "System.Byte[]": return "esSystemType.ByteArray";
        case "System.SByte[]": return "esSystemType.SByteArray";
        case "System.Char[]": return "esSystemType.CharArray";
        case "System.Decimal[]": return "esSystemType.DecimalArray";
        case "System.Double[]": return "esSystemType.DoubleArray";
        case "System.Single[]": return "esSystemType.SingleArray";
        case "System.Int32[]": return "esSystemType.Int32Array";
        case "System.UInt32[]": return "esSystemType.UInt32Array";
        case "System.Int64[]": return "esSystemType.Int64Array";
        case "System.UInt64[]": return "esSystemType.UInt64Array";
        case "System.Object[]": return "esSystemType.ObjectArray";
        case "System.Int16[]": return "esSystemType.Int16Array";
        case "System.UInt16[]": return "esSystemType.UInt16Array";
        case "System.String[]": return "esSystemType.StringArray";
        case "System.DateTime[]": return "esSystemType.DateTimeArray";
        case "System.DateTimeOffset[]": return "esSystemType.DateTimeOffsetArray";
        case "System.TimeSpan[]": return "esSystemType.TimeSpanArray";
        case "System.Guid[]": return "esSystemType.GuidArray";

        default: return "esSystemType.Unassigned";
      }
    }

    /// <summary>
    /// Returns true if the IColumn.LanguageType is an array data type such as System.Byte[]
    /// </summary>
    /// <example>
    /// C# Template Code
    /// <code>
    /// ITable table = MyMeta.Databases["Northwind"].Tables["Employees"];
    /// foreach(IColumn col in table.Columns)
    /// {
    ///     if(esPlugIn.IsArrayType(col))
    ///     {
    ///			&lt;%=col.Name%&gt; = &lt;%=col.LanguageType%&gt; = &lt;%=col.NullableType(col)%&gt;
    ///     }
    /// }    
    /// 
    /// // The code above produces
    /// Photo = image = System.Byte[]
    /// </code>
    /// </example>
    /// <param name="column"></param>
    /// <returns></returns>
    public bool IsArrayType(IColumn column)
    {
      return IsArrayType(column.LanguageType);
    }

    /// <summary>
    /// Returns true if the IColumn.LanguageType is an array data type such as System.Byte[]
    /// </summary>
    /// <example>
    /// C# Template Code
    /// <code>
    ///  if(esPlugIn.IsArrayType("System.Byte[]"))
    ///  {
    ///		output.writeln("Yes, it is");
    ///  }
    ///  
    /// // The code above produces
    /// Yes, it is
    /// </code>
    /// </example>
    /// <param name="type">An IColumn.LanguageType</param>
    /// <returns></returns>
    public bool IsArrayType(string type)
    {
      if (type.EndsWith("[]") || type.EndsWith("()"))
        return true;
      else
        return false;
    }

    /// <summary>
    /// Returns true if the IColumn.LanguageType is equal to "System.Object"
    /// </summary>
    /// <param name="column">The IColumn</param>
    /// <returns></returns>
    public bool IsObjectType(IColumn column)
    {
      return IsObjectType(column.LanguageType);
    }

    /// <summary>
    /// Returns true if the type is equal to "System.Object"
    /// </summary>
    /// <param name="type">The type (an IColumns.LanguageType)</param>
    /// <returns></returns>		
    public bool IsObjectType(string type)
    {
      type = CSharpToSystemType(type);

      if (type == "System.Object")
        return true;
      else
        return false;
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="column"></param>
    /// <returns></returns>
    public bool IsNullableType(IColumn column)
    {
      var newType = CSharpToSystemType(column.LanguageType);

      switch (newType)
      {
        case "System.Int16":
        case "System.Int32":
        case "System.Int64":
        case "System.UInt16":
        case "System.UInt32":
        case "System.UInt64":
        case "System.Boolean":
        case "System.DateTime":
        case "System.DateTimeOffset":
        case "System.TimeSpan":
        case "System.Decimal":
        case "System.Double":
        case "System.Byte":
        case "System.SByte":
        case "System.Single":
        case "System.Guid":

          if (Settings.UseNullableTypesAlways || column.IsNullable)
            return true;
          else
            return false;

        default:
          return false;
      }
    }

    /// <summary>
    /// 
    /// </summary>
    /// <param name="type"></param>
    /// <returns></returns>
    public bool IsNullableType(string type)
    {
      var newType = CSharpToSystemType(type);

      switch (newType)
      {
        case "System.Int16":
        case "System.Int32":
        case "System.Int64":
        case "System.UInt16":
        case "System.UInt32":
        case "System.UInt64":
        case "System.Boolean":
        case "System.DateTime":
        case "System.DateTimeOffset":
        case "System.TimeSpan":
        case "System.Decimal":
        case "System.Double":
        case "System.Byte":
        case "System.SByte":
        case "System.Single":
        case "System.Guid":
          return true;

        default:
          return false;
      }
    }

    /// <summary>
    /// Currently for internal use only
    /// </summary>
    /// <param name="column"></param>
    /// <returns></returns>
    public string GetRowAccessor(IColumn column)
    {
      var type = CSharpToSystemType(column.LanguageType);

      var acc = type.Replace(".", "");
      if (acc.EndsWith("[]"))
      {
        acc = acc.Replace("[]", "Array");
      }
      else
      {
        // Nullable types won't end with []
        if (!Settings.UseNullableTypesAlways && !column.IsNullable)
        {
          acc += "Required";
        }
      }
      return "Get" + acc;
    }

    /// <summary>
    /// Currently for internal use only
    /// </summary>
    /// <param name="type"></param>
    /// <returns></returns>
    public string GetRowAccessor(string type)
    {
      type = CSharpToSystemType(type);

      var acc = type.Replace(".", "");
      if (acc.EndsWith("[]"))
      {
        acc = acc.Replace("[]", "Array");
      }
      return "Get" + acc;
    }

    /// <summary>
    /// Currently for internal use only
    /// </summary>
    /// <param name="column"></param>
    /// <returns></returns>
    public string SetRowAccessor(IColumn column)
    {
      return SetRowAccessor(column.LanguageType);
    }

    /// <summary>
    /// Currently for internal use only
    /// </summary>
    /// <param name="type"></param>
    /// <returns></returns>
    public string SetRowAccessor(string type)
    {
      type = CSharpToSystemType(type);

      var acc = type.Replace(".", "");
      if (acc.EndsWith("[]"))
      {
        acc = acc.Replace("[]", "Array");
      }
      return "Set" + acc;
    }


    /// <summary>
    /// Currently for internal use only
    /// </summary>
    /// <param name="column"></param>
    /// <param name="variableName"></param>
    /// <returns></returns>
    public string GetStringConversion(IColumn column, string variableName)
    {
      return GetStringConversion(column.LanguageType, variableName);
    }

    /// <summary>
    /// Currently for internal use only
    /// </summary>
    /// <param name="type"></param>
    /// <param name="variableName"></param>
    /// <returns></returns>
    public string GetStringConversion(string type, string variableName)
    {
      type = CSharpToSystemType(type);

      var str = "";

      var i = type.IndexOf('.');

      if (i != -1)
      {
        str = type.Substring(i + 1);

        switch (str)
        {
          case "TimeSpan":
            str = variableName + ".ToString()";
            break;

          default:
            str = "Convert.ToString(" + variableName + ")";
            break;
        }
      }

      return str;
    }

    /// <summary>
    /// Currently for internal use only
    /// </summary>
    /// <param name="column"></param>
    /// <param name="variableName"></param>
    /// <returns></returns>
    public string SetStringConversion(IColumn column, string variableName)
    {
      return SetStringConversion(column.LanguageType, variableName);
    }

    /// <summary>
    /// Currently for internal use only
    /// </summary>
    /// <param name="type"></param>
    /// <param name="variableName"></param>
    /// <returns></returns>
    public string SetStringConversion(string type, string variableName)
    {
      type = CSharpToSystemType(type);

      var str = "";

      var i = type.IndexOf('.');

      if (i != -1)
      {
        str = type.Substring(i + 1);

        switch (str)
        {
          case "Guid":
            str = "new Guid(" + variableName + ")";
            break;

          case "DateTimeOffset":
            str = "DateTimeOffset.Parse(" + variableName + ")";
            break;

          case "TimeSpan":
            str = "TimeSpan.Parse(" + variableName + ")";
            break;

          default:
            str = "Convert.To" + str + "(" + variableName + ")";
            break;
        }
      }

      return str;
    }

    /// <summary>
    /// The Utils MyGeneration Plugin Instance to use.
    /// </summary>
    /// <remarks>Utils is also a MyGeneration plugin and it is an intrinsic object that is shipped with MyGeneration 1.1.5.0 and onward.
    /// You just need to assign it before you use the esPlugIn in the template body as shown below in the code sample.
    /// </remarks>
    /// <example>
    /// C# Template Code
    /// <code>
    ///	esPlugIn.Utils = Utils;
    /// </code>
    /// </example>
    public Utils Utils
    {
      get => utils;
      set => utils = value;
    }

    /// <summary>
    /// Set this to true to disable the Pascal naming convention.
    /// </summary>
    /// <remarks>
    /// The default for UseRawNames is false. It is not recommend that you set this to true. Pascal/Camel casing is the industry
    /// recommend standard and has been now for a decade. However, if you do set this to true then <see cref="sTrimList"/> is used
    /// to remove any characters that would be illegal and cause a compile error.
    /// </remarks>>
    public bool PreserveUnderscores => Settings.PreserveUnderscores;

    /// <summary>
    /// Set this to true to disable the Pascal naming convention.
    /// </summary>
    /// <remarks>
    /// The default for UseRawNames is false. It is not recommend that you set this to true. Pascal/Camel casing is the industry
    /// recommend standard and has been now for a decade. However, if you do set this to true then <see cref="sTrimList"/> is used
    /// to remove any characters that would be illegal and cause a compile error.
    /// </remarks>>
    public bool UseRawNames => Settings.UseRawNames;

    /// <summary>
    /// 
    /// </summary>
    public bool UseNullableTypesAlways => Settings.UseNullableTypesAlways;

    /// <summary>
    /// 
    /// </summary>
    public bool TurnOffDateTimeInClassHeaders => Settings.TurnOffDateTimeInClassHeaders;

    /// <summary>
    /// Set this to true to change from the default EntityVerb order
    /// for the Procedure name to VerbEntity order.
    /// </summary>
    /// <remarks>
    /// The default for ProcVerbFirst is false. It is not recommend that you set this to true.
    /// The default names allow all Employees Stored
    /// Procedures to be grouped together in an alphabetical list.
    /// </remarks>
    /// <example>
    /// The default Insert Stored Procedure name for the
    /// table "Employees" would be:
    /// <code>
    ///	proc_EmployeesInsert
    /// </code>
    /// With ProcVerbFirst set to true:
    /// <code>
    ///	esPlugIn.ProcVerbFirst = true;
    /// </code>
    /// You get:
    /// <code>
    ///	proc_InsertEmployees
    /// </code>
    /// </example>
    public bool ProcVerbFirst => Settings.ProcVerbFirst;

    #endregion

    #region Private Helper Methods
    public string ToPascalCase(string str)
    {
      return Utils.SetPascalCase(str, Settings);
    }

    public string ToCamelCase(string str)
    {
      return Utils.SetCamelCase(str, Settings);
    }

    private string EntityCore(string name)
    {
      return Utils.SetPascalCase(name, Settings);
    }

    #endregion

    private Utils utils = new Utils();
  }
}
